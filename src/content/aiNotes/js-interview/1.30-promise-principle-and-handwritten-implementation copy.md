---
title: 1.30 - PromiseåŸç†ã€æ‰‹å†™Promise
aiNotebook: js-interview
date: 2026-01-30
tags: ['JavaScript', 'Promise', 'é¢è¯•']
excerpt: PromiseåŸç†ã€å¹¶æ‰‹å†™Promise
order: 5
---

# Promise æ·±åº¦è§£æä¸æ‰‹å†™å®ç°

> ä»åŸç†åˆ°å®è·µï¼Œå½»åº•æŒæ¡ Promise çš„æ ¸å¿ƒæœºåˆ¶

## ç›®å½•

1. [Promise åŸºç¡€æ¦‚å¿µ](#ä¸€promise-åŸºç¡€æ¦‚å¿µ)
2. [Promise æ ¸å¿ƒåŸç†](#äºŒpromise-æ ¸å¿ƒåŸç†)
3. [æ‰‹å†™ Promise - åŸºç¡€ç‰ˆ](#ä¸‰æ‰‹å†™-promise---åŸºç¡€ç‰ˆ)
4. [æ‰‹å†™ Promise - å®Œæ•´ç‰ˆ](#å››æ‰‹å†™-promise---å®Œæ•´ç‰ˆ)
5. [Promise é™æ€æ–¹æ³•å®ç°](#äº”promise-é™æ€æ–¹æ³•å®ç°)
6. [Promise é«˜çº§ç‰¹æ€§](#å…­promise-é«˜çº§ç‰¹æ€§)
7. [å¸¸è§é¢è¯•é¢˜](#ä¸ƒå¸¸è§é¢è¯•é¢˜)
8. [å®æˆ˜åº”ç”¨åœºæ™¯](#å…«å®æˆ˜åº”ç”¨åœºæ™¯)

---

## ä¸€ã€Promise åŸºç¡€æ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯ Promise?

Promise æ˜¯å¼‚æ­¥ç¼–ç¨‹çš„ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œæ¯”ä¼ ç»Ÿçš„å›è°ƒå‡½æ•°å’Œäº‹ä»¶æ›´åˆç†ã€æ›´å¼ºå¤§ã€‚å®ƒæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æœ€ç»ˆå®Œæˆï¼ˆæˆ–å¤±è´¥ï¼‰åŠå…¶ç»“æœå€¼ã€‚

### 1.2 Promise çš„ä¸‰ç§çŠ¶æ€

```javascript
// Promise æœ‰ä¸”åªæœ‰ä¸‰ç§çŠ¶æ€
const PENDING = 'pending';     // åˆå§‹çŠ¶æ€ï¼Œæ—¢ä¸æ˜¯æˆåŠŸï¼Œä¹Ÿä¸æ˜¯å¤±è´¥
const FULFILLED = 'fulfilled'; // æ“ä½œæˆåŠŸå®Œæˆ
const REJECTED = 'rejected';   // æ“ä½œå¤±è´¥
```

**çŠ¶æ€è½¬æ¢è§„åˆ™ï¼ˆæ ¸å¿ƒï¼‰ï¼š**
- çŠ¶æ€åªèƒ½ä» `pending` â†’ `fulfilled` æˆ– `pending` â†’ `rejected`
- çŠ¶æ€ä¸€æ—¦æ”¹å˜ï¼Œå°±ä¸ä¼šå†å˜ï¼Œä»»ä½•æ—¶å€™éƒ½å¯ä»¥å¾—åˆ°è¿™ä¸ªç»“æœ
- `fulfilled` å’Œ `rejected` çŠ¶æ€ä¸å¯é€†ï¼Œä¸èƒ½ç›¸äº’è½¬æ¢

### 1.3 Promise çš„åŸºæœ¬ä½¿ç”¨

```javascript
// åˆ›å»º Promise
const promise = new Promise((resolve, reject) => {
  // å¼‚æ­¥æ“ä½œ
  setTimeout(() => {
    const success = Math.random() > 0.5;
    if (success) {
      resolve('æ“ä½œæˆåŠŸ'); // å°†çŠ¶æ€æ”¹ä¸º fulfilled
    } else {
      reject('æ“ä½œå¤±è´¥');  // å°†çŠ¶æ€æ”¹ä¸º rejected
    }
  }, 1000);
});

// ä½¿ç”¨ Promise
promise
  .then(
    result => console.log(result),  // æˆåŠŸå›è°ƒ
    error => console.log(error)     // å¤±è´¥å›è°ƒ
  )
  .catch(error => console.log(error)) // æ•è·é”™è¯¯
  .finally(() => console.log('å®Œæˆ')); // æ— è®ºæˆåŠŸå¤±è´¥éƒ½æ‰§è¡Œ
```

---

## äºŒã€Promise æ ¸å¿ƒåŸç†

### 2.1 Promise çš„æ ¸å¿ƒæœºåˆ¶

Promise çš„å®ç°åŸºäºä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒæœºåˆ¶ï¼š

#### 1. **çŠ¶æ€ç®¡ç†**
```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';      // å½“å‰çŠ¶æ€
    this.value = undefined;      // æˆåŠŸçš„å€¼
    this.reason = undefined;     // å¤±è´¥çš„åŸå› 
  }
}
```

#### 2. **å›è°ƒé˜Ÿåˆ—**
```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];  // æˆåŠŸå›è°ƒé˜Ÿåˆ—
    this.onRejectedCallbacks = [];   // å¤±è´¥å›è°ƒé˜Ÿåˆ—
  }
}
```

ä¸ºä»€ä¹ˆéœ€è¦å›è°ƒé˜Ÿåˆ—ï¼Ÿ
- Promise å¯èƒ½åœ¨å¼‚æ­¥æ“ä½œå®Œæˆå‰å°±è°ƒç”¨ `.then()`
- æ­¤æ—¶çŠ¶æ€è¿˜æ˜¯ `pending`ï¼Œéœ€è¦å…ˆå­˜å‚¨å›è°ƒå‡½æ•°
- ç­‰çŠ¶æ€æ”¹å˜åï¼Œå†ä¾æ¬¡æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„å›è°ƒ

#### 3. **then æ–¹æ³•é“¾å¼è°ƒç”¨**
```javascript
// then æ–¹æ³•å¿…é¡»è¿”å›ä¸€ä¸ªæ–°çš„ Promise
promise
  .then(result => result * 2)
  .then(result => result + 1)
  .then(result => console.log(result));
```

### 2.2 Promise æ‰§è¡Œæµç¨‹å›¾

```
åˆ›å»º Promise
    â†“
æ‰§è¡Œ executor
    â†“
åŒæ­¥/å¼‚æ­¥æ“ä½œ
    â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         â”‚         â”‚
resolve   reject    pending
  â”‚         â”‚         â”‚
fulfilled rejected  ç­‰å¾…ä¸­
  â”‚         â”‚         â”‚
æ‰§è¡ŒæˆåŠŸ  æ‰§è¡Œå¤±è´¥  å­˜å‚¨å›è°ƒ
å›è°ƒé˜Ÿåˆ—  å›è°ƒé˜Ÿåˆ—    åˆ°é˜Ÿåˆ—
  â”‚         â”‚         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    è¿”å›æ–° Promise
         â†“
      é“¾å¼è°ƒç”¨
```

### 2.3 å…³é”®æ¦‚å¿µç†è§£

#### Promise Resolution Procedureï¼ˆPromise è§£å†³è¿‡ç¨‹ï¼‰

è¿™æ˜¯ Promise æœ€å¤æ‚çš„éƒ¨åˆ†ï¼Œç”¨äºå¤„ç† `then` è¿”å›å€¼ï¼š

```javascript
// æƒ…å†µ 1: è¿”å›æ™®é€šå€¼
promise.then(() => 123); // æ–° Promise çš„å€¼æ˜¯ 123

// æƒ…å†µ 2: è¿”å›æ–°çš„ Promise
promise.then(() => new Promise(resolve => resolve(456))); // éœ€è¦ç­‰å¾…è¿™ä¸ª Promise

// æƒ…å†µ 3: è¿”å›è‡ªèº«
const p = promise.then(() => p); // éœ€è¦æŠ›å‡ºé”™è¯¯ï¼Œé¿å…å¾ªç¯å¼•ç”¨

// æƒ…å†µ 4: è¿”å› thenable å¯¹è±¡
promise.then(() => ({
  then: (resolve) => resolve(789)
})); // éœ€è¦è°ƒç”¨å…¶ then æ–¹æ³•
```

---

## ä¸‰ã€æ‰‹å†™ Promise - åŸºç¡€ç‰ˆ

### 3.1 æœ€ç®€å•çš„ Promise å®ç°

```javascript
class MyPromise {
  constructor(executor) {
    // åˆå§‹åŒ–çŠ¶æ€
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;

    // resolve å‡½æ•°
    const resolve = (value) => {
      // åªæœ‰ pending çŠ¶æ€æ‰èƒ½è½¬æ¢
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
      }
    };

    // reject å‡½æ•°
    const reject = (reason) => {
      // åªæœ‰ pending çŠ¶æ€æ‰èƒ½è½¬æ¢
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
      }
    };

    // ç«‹å³æ‰§è¡Œ executor
    try {
      executor(resolve, reject);
    } catch (error) {
      // executor æ‰§è¡Œå‡ºé”™ï¼Œç›´æ¥ reject
      reject(error);
    }
  }

  // then æ–¹æ³•
  then(onFulfilled, onRejected) {
    // æ ¹æ®çŠ¶æ€æ‰§è¡Œå¯¹åº”å›è°ƒ
    if (this.state === 'fulfilled') {
      onFulfilled(this.value);
    }
    if (this.state === 'rejected') {
      onRejected(this.reason);
    }
  }
}

// æµ‹è¯•
const promise = new MyPromise((resolve, reject) => {
  resolve('æˆåŠŸ');
});

promise.then(
  value => console.log(value),   // è¾“å‡º: æˆåŠŸ
  reason => console.log(reason)
);
```

**è¿™ä¸ªç‰ˆæœ¬çš„é—®é¢˜ï¼š**
1. âŒ ä¸æ”¯æŒå¼‚æ­¥æ“ä½œ
2. âŒ ä¸æ”¯æŒé“¾å¼è°ƒç”¨
3. âŒ æ²¡æœ‰å¤„ç†å›è°ƒé˜Ÿåˆ—

### 3.2 æ”¯æŒå¼‚æ­¥æ“ä½œ

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    // æ–°å¢ï¼šå›è°ƒé˜Ÿåˆ—
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        // æ‰§è¡Œæ‰€æœ‰æˆåŠŸå›è°ƒ
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        // æ‰§è¡Œæ‰€æœ‰å¤±è´¥å›è°ƒ
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      onFulfilled(this.value);
    }
    if (this.state === 'rejected') {
      onRejected(this.reason);
    }
    // æ–°å¢ï¼šå¤„ç†å¼‚æ­¥æƒ…å†µ
    if (this.state === 'pending') {
      // å°†å›è°ƒå­˜å…¥é˜Ÿåˆ—
      this.onFulfilledCallbacks.push(() => {
        onFulfilled(this.value);
      });
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason);
      });
    }
  }
}

// æµ‹è¯•å¼‚æ­¥
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('å¼‚æ­¥æˆåŠŸ');
  }, 1000);
});

promise.then(
  value => console.log(value),   // 1ç§’åè¾“å‡º: å¼‚æ­¥æˆåŠŸ
  reason => console.log(reason)
);
```

---

## å››ã€æ‰‹å†™ Promise - å®Œæ•´ç‰ˆ

### 4.1 ç¬¦åˆ Promises/A+ è§„èŒƒçš„å®Œæ•´å®ç°

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      // å¦‚æœ resolve çš„æ˜¯ä¸€ä¸ª Promiseï¼Œéœ€è¦ç­‰å¾…å…¶å®Œæˆ
      if (value instanceof MyPromise) {
        return value.then(resolve, reject);
      }

      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    // å‚æ•°æ ¡éªŒï¼Œç¡®ä¿æ˜¯å‡½æ•°
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

    // è¿”å›æ–°çš„ Promiseï¼Œå®ç°é“¾å¼è°ƒç”¨
    const promise2 = new MyPromise((resolve, reject) => {
      
      // å°è£…æˆåŠŸå›è°ƒ
      const fulfilledMicrotask = () => {
        // ä½¿ç”¨ queueMicrotask æ¨¡æ‹Ÿå¾®ä»»åŠ¡
        queueMicrotask(() => {
          try {
            const x = onFulfilled(this.value);
            // Promise è§£å†³è¿‡ç¨‹
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      // å°è£…å¤±è´¥å›è°ƒ
      const rejectedMicrotask = () => {
        queueMicrotask(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      // æ ¹æ®çŠ¶æ€æ‰§è¡Œå¯¹åº”é€»è¾‘
      if (this.state === 'fulfilled') {
        fulfilledMicrotask();
      } else if (this.state === 'rejected') {
        rejectedMicrotask();
      } else if (this.state === 'pending') {
        this.onFulfilledCallbacks.push(fulfilledMicrotask);
        this.onRejectedCallbacks.push(rejectedMicrotask);
      }
    });

    return promise2;
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  finally(onFinally) {
    return this.then(
      value => MyPromise.resolve(onFinally()).then(() => value),
      reason => MyPromise.resolve(onFinally()).then(() => { throw reason })
    );
  }
}

/**
 * Promise è§£å†³è¿‡ç¨‹
 * è¿™æ˜¯ Promise æœ€æ ¸å¿ƒçš„éƒ¨åˆ†
 */
function resolvePromise(promise2, x, resolve, reject) {
  // 1. å¦‚æœ promise2 å’Œ x æŒ‡å‘åŒä¸€å¯¹è±¡ï¼ŒæŠ›å‡º TypeError
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected for promise'));
  }

  // 2. å¦‚æœ x æ˜¯ Promise å®ä¾‹
  if (x instanceof MyPromise) {
    x.then(resolve, reject);
    return;
  }

  // 3. å¦‚æœ x æ˜¯å¯¹è±¡æˆ–å‡½æ•°
  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let called = false; // é˜²æ­¢å¤šæ¬¡è°ƒç”¨

    try {
      const then = x.then;

      // å¦‚æœ then æ˜¯å‡½æ•°ï¼Œè®¤ä¸º x æ˜¯ thenable å¯¹è±¡
      if (typeof then === 'function') {
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            // é€’å½’è§£æ
            resolvePromise(promise2, y, resolve, reject);
          },
          r => {
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        // then ä¸æ˜¯å‡½æ•°ï¼Œç›´æ¥ resolve
        resolve(x);
      }
    } catch (error) {
      if (called) return;
      called = true;
      reject(error);
    }
  } else {
    // 4. x æ˜¯æ™®é€šå€¼ï¼Œç›´æ¥ resolve
    resolve(x);
  }
}
```

### 4.2 å…³é”®ç‚¹è¯¦è§£

#### 1. ä¸ºä»€ä¹ˆéœ€è¦ queueMicrotaskï¼Ÿ

```javascript
// åŸç”Ÿ Promise çš„å›è°ƒæ˜¯å¾®ä»»åŠ¡
Promise.resolve().then(() => console.log(1));
console.log(2);
// è¾“å‡º: 2, 1

// æˆ‘ä»¬çš„å®ç°ä¹Ÿè¦ä¿è¯è¿™ä¸ªé¡ºåº
new MyPromise(resolve => resolve()).then(() => console.log(1));
console.log(2);
// è¾“å‡º: 2, 1
```

#### 2. resolvePromise ä¸ºä»€ä¹ˆè¿™ä¹ˆå¤æ‚ï¼Ÿ

```javascript
// åœºæ™¯ 1: è¿”å›æ™®é€šå€¼
promise.then(() => 123);

// åœºæ™¯ 2: è¿”å› Promise
promise.then(() => new Promise(resolve => resolve(456)));

// åœºæ™¯ 3: è¿”å› thenable å¯¹è±¡
promise.then(() => ({
  then: (resolve) => setTimeout(() => resolve(789), 1000)
}));

// åœºæ™¯ 4: å¾ªç¯å¼•ç”¨
const p = promise.then(() => p); // å¿…é¡»æŠ›å‡ºé”™è¯¯

// åœºæ™¯ 5: åµŒå¥— Promise
promise.then(() => 
  new Promise(resolve => 
    resolve(new Promise(r => r(999)))
  )
);
```

#### 3. called æ ‡å¿—çš„ä½œç”¨

```javascript
// é˜²æ­¢ thenable å¯¹è±¡å¤šæ¬¡è°ƒç”¨ resolve/reject
const thenable = {
  then: (resolve, reject) => {
    resolve(1);
    resolve(2); // åº”è¯¥è¢«å¿½ç•¥
    reject(3);  // åº”è¯¥è¢«å¿½ç•¥
  }
};

MyPromise.resolve(thenable).then(value => {
  console.log(value); // åªè¾“å‡º 1
});
```

---

## äº”ã€Promise é™æ€æ–¹æ³•å®ç°

### 5.1 Promise.resolve

```javascript
MyPromise.resolve = function(value) {
  // å¦‚æœæ˜¯ Promise å®ä¾‹ï¼Œç›´æ¥è¿”å›
  if (value instanceof MyPromise) {
    return value;
  }

  // å¦‚æœæ˜¯ thenable å¯¹è±¡
  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
    return new MyPromise((resolve, reject) => {
      value.then(resolve, reject);
    });
  }

  // æ™®é€šå€¼ï¼Œè¿”å›æˆåŠŸçš„ Promise
  return new MyPromise(resolve => resolve(value));
};

// æµ‹è¯•
MyPromise.resolve(123).then(value => console.log(value)); // 123
MyPromise.resolve(MyPromise.resolve(456)).then(value => console.log(value)); // 456
```

### 5.2 Promise.reject

```javascript
MyPromise.reject = function(reason) {
  // æ— è®ºä¼ å…¥ä»€ä¹ˆï¼Œéƒ½è¿”å›å¤±è´¥çš„ Promise
  return new MyPromise((resolve, reject) => reject(reason));
};

// æµ‹è¯•
MyPromise.reject('error').catch(reason => console.log(reason)); // error
```

### 5.3 Promise.all

```javascript
MyPromise.all = function(promises) {
  return new MyPromise((resolve, reject) => {
    // å‚æ•°æ ¡éªŒ
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    const results = [];
    let completedCount = 0;
    const length = promises.length;

    // ç©ºæ•°ç»„ç›´æ¥è¿”å›
    if (length === 0) {
      return resolve(results);
    }

    promises.forEach((promise, index) => {
      // å°†é Promise å€¼è½¬ä¸º Promise
      MyPromise.resolve(promise).then(
        value => {
          results[index] = value;
          completedCount++;

          // æ‰€æœ‰ Promise éƒ½å®Œæˆ
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          // ä»»ä½•ä¸€ä¸ªå¤±è´¥ï¼Œç«‹å³ reject
          reject(reason);
        }
      );
    });
  });
};

// æµ‹è¯•
MyPromise.all([
  MyPromise.resolve(1),
  MyPromise.resolve(2),
  MyPromise.resolve(3)
]).then(values => console.log(values)); // [1, 2, 3]

MyPromise.all([
  MyPromise.resolve(1),
  MyPromise.reject('error'),
  MyPromise.resolve(3)
]).catch(reason => console.log(reason)); // error
```

### 5.4 Promise.race

```javascript
MyPromise.race = function(promises) {
  return new MyPromise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    // ç©ºæ•°ç»„ï¼Œæ°¸è¿œ pending
    if (promises.length === 0) {
      return;
    }

    promises.forEach(promise => {
      // ç¬¬ä¸€ä¸ªå®Œæˆçš„ Promise å†³å®šç»“æœ
      MyPromise.resolve(promise).then(resolve, reject);
    });
  });
};

// æµ‹è¯•
MyPromise.race([
  new MyPromise(resolve => setTimeout(() => resolve(1), 1000)),
  new MyPromise(resolve => setTimeout(() => resolve(2), 500)),
  new MyPromise(resolve => setTimeout(() => resolve(3), 800))
]).then(value => console.log(value)); // 500ms åè¾“å‡º 2
```

### 5.5 Promise.allSettled

```javascript
MyPromise.allSettled = function(promises) {
  return new MyPromise((resolve) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    const results = [];
    let completedCount = 0;
    const length = promises.length;

    if (length === 0) {
      return resolve(results);
    }

    promises.forEach((promise, index) => {
      MyPromise.resolve(promise).then(
        value => {
          results[index] = { status: 'fulfilled', value };
          completedCount++;
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          results[index] = { status: 'rejected', reason };
          completedCount++;
          if (completedCount === length) {
            resolve(results);
          }
        }
      );
    });
  });
};

// æµ‹è¯•
MyPromise.allSettled([
  MyPromise.resolve(1),
  MyPromise.reject('error'),
  MyPromise.resolve(3)
]).then(results => console.log(results));
// [
//   { status: 'fulfilled', value: 1 },
//   { status: 'rejected', reason: 'error' },
//   { status: 'fulfilled', value: 3 }
// ]
```

### 5.6 Promise.any

```javascript
MyPromise.any = function(promises) {
  return new MyPromise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    const errors = [];
    let rejectedCount = 0;
    const length = promises.length;

    if (length === 0) {
      return reject(new AggregateError([], 'All promises were rejected'));
    }

    promises.forEach((promise, index) => {
      MyPromise.resolve(promise).then(
        value => {
          // ä»»ä½•ä¸€ä¸ªæˆåŠŸï¼Œç«‹å³ resolve
          resolve(value);
        },
        reason => {
          errors[index] = reason;
          rejectedCount++;

          // æ‰€æœ‰éƒ½å¤±è´¥ï¼Œæ‰ reject
          if (rejectedCount === length) {
            reject(new AggregateError(errors, 'All promises were rejected'));
          }
        }
      );
    });
  });
};

// æµ‹è¯•
MyPromise.any([
  MyPromise.reject('error1'),
  MyPromise.resolve(2),
  MyPromise.reject('error3')
]).then(value => console.log(value)); // 2

MyPromise.any([
  MyPromise.reject('error1'),
  MyPromise.reject('error2')
]).catch(error => console.log(error)); // AggregateError
```

---

## å…­ã€Promise é«˜çº§ç‰¹æ€§

### 6.1 Promise é“¾å¼è°ƒç”¨çš„å€¼ä¼ é€’

```javascript
// å€¼ç©¿é€
Promise.resolve(1)
  .then()           // æ²¡æœ‰å¤„ç†å‡½æ•°
  .then()           // æ²¡æœ‰å¤„ç†å‡½æ•°
  .then(value => {
    console.log(value); // 1
  });

// å®ç°åŸç†
then(onFulfilled, onRejected) {
  // å¦‚æœä¸æ˜¯å‡½æ•°ï¼Œæä¾›é»˜è®¤å‡½æ•°
  onFulfilled = typeof onFulfilled === 'function' 
    ? onFulfilled 
    : value => value; // å€¼ç©¿é€

  onRejected = typeof onRejected === 'function' 
    ? onRejected 
    : reason => { throw reason }; // é”™è¯¯ç©¿é€
}
```

### 6.2 é”™è¯¯å¤„ç†æœºåˆ¶

```javascript
// é”™è¯¯ä¼šä¸€ç›´ä¼ é€’ï¼Œç›´åˆ°è¢« catch
Promise.resolve()
  .then(() => {
    throw new Error('é”™è¯¯1');
  })
  .then(() => {
    console.log('ä¸ä¼šæ‰§è¡Œ');
  })
  .then(() => {
    console.log('ä¸ä¼šæ‰§è¡Œ');
  })
  .catch(error => {
    console.log(error.message); // é”™è¯¯1
    return 'recovered';
  })
  .then(value => {
    console.log(value); // recovered
  });
```

### 6.3 Promise çš„ä¸­æ–­

```javascript
// Promise æ²¡æœ‰å®˜æ–¹çš„ä¸­æ–­æ–¹æ³•ï¼Œä½†å¯ä»¥é€šè¿‡è¿”å›ä¸€ä¸ªæ°¸è¿œ pending çš„ Promise æ¥"ä¸­æ–­"
function interruptPromise() {
  return new Promise(() => {}); // æ°¸è¿œä¸ resolve ä¹Ÿä¸ reject
}

Promise.resolve()
  .then(() => {
    console.log('step 1');
    return interruptPromise(); // åç»­ä¸ä¼šæ‰§è¡Œ
  })
  .then(() => {
    console.log('ä¸ä¼šæ‰§è¡Œ');
  });
```

### 6.4 Promise çš„é‡è¯•æœºåˆ¶

```javascript
/**
 * Promise é‡è¯•å‡½æ•°
 * @param {Function} fn - éœ€è¦é‡è¯•çš„å‡½æ•°
 * @param {Number} times - é‡è¯•æ¬¡æ•°
 * @param {Number} delay - é‡è¯•å»¶è¿Ÿ
 */
function retry(fn, times = 3, delay = 1000) {
  return new Promise((resolve, reject) => {
    function attempt(remainingTimes) {
      fn()
        .then(resolve)
        .catch(error => {
          if (remainingTimes === 0) {
            reject(error);
          } else {
            console.log(`å¤±è´¥ï¼Œ${delay}ms åé‡è¯•ï¼Œå‰©ä½™æ¬¡æ•°: ${remainingTimes}`);
            setTimeout(() => {
              attempt(remainingTimes - 1);
            }, delay);
          }
        });
    }
    attempt(times);
  });
}

// ä½¿ç”¨ç¤ºä¾‹
let count = 0;
const unstableApi = () => {
  return new Promise((resolve, reject) => {
    count++;
    if (count < 3) {
      reject(`å¤±è´¥ ${count} æ¬¡`);
    } else {
      resolve('æˆåŠŸ');
    }
  });
};

retry(unstableApi, 5, 500)
  .then(result => console.log(result))
  .catch(error => console.log(error));
```

### 6.5 Promise å¹¶å‘æ§åˆ¶

```javascript
/**
 * å¹¶å‘æ§åˆ¶å‡½æ•°
 * @param {Array} tasks - ä»»åŠ¡æ•°ç»„
 * @param {Number} limit - å¹¶å‘é™åˆ¶
 */
function concurrentControl(tasks, limit = 2) {
  return new Promise((resolve) => {
    const results = [];
    let runningCount = 0;
    let completedCount = 0;
    let index = 0;

    function run() {
      while (runningCount < limit && index < tasks.length) {
        const currentIndex = index;
        const task = tasks[index++];
        runningCount++;

        task()
          .then(result => {
            results[currentIndex] = result;
          })
          .catch(error => {
            results[currentIndex] = error;
          })
          .finally(() => {
            runningCount--;
            completedCount++;

            if (completedCount === tasks.length) {
              resolve(results);
            } else {
              run();
            }
          });
      }
    }

    run();
  });
}

// ä½¿ç”¨ç¤ºä¾‹
const tasks = [
  () => new Promise(resolve => setTimeout(() => resolve('ä»»åŠ¡1'), 1000)),
  () => new Promise(resolve => setTimeout(() => resolve('ä»»åŠ¡2'), 500)),
  () => new Promise(resolve => setTimeout(() => resolve('ä»»åŠ¡3'), 800)),
  () => new Promise(resolve => setTimeout(() => resolve('ä»»åŠ¡4'), 300)),
  () => new Promise(resolve => setTimeout(() => resolve('ä»»åŠ¡5'), 600))
];

concurrentControl(tasks, 2).then(results => {
  console.log(results);
});
```

---

## ä¸ƒã€å¸¸è§é¢è¯•é¢˜

### 7.1 Promise æ‰§è¡Œé¡ºåºé¢˜

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

new Promise((resolve) => {
  console.log('4');
  resolve();
}).then(() => {
  console.log('5');
}).then(() => {
  console.log('6');
});

console.log('7');

// è¾“å‡ºé¡ºåº: 1, 4, 7, 5, 6, 2, 3

/**
 * è§£æ:
 * 1. åŒæ­¥ä»£ç : 1, 4, 7
 * 2. å¾®ä»»åŠ¡é˜Ÿåˆ—: 5 -> 6
 * 3. å®ä»»åŠ¡é˜Ÿåˆ—: 2 -> å¾®ä»»åŠ¡ 3
 */
```

### 7.2 Promise çº¢ç»¿ç¯é—®é¢˜

```javascript
// çº¢ç¯3ç§’äº®ä¸€æ¬¡ï¼Œç»¿ç¯2ç§’äº®ä¸€æ¬¡ï¼Œé»„ç¯1ç§’äº®ä¸€æ¬¡
// å®ç°ä¸€ä¸ªå‡½æ•°è®©ä¸‰ä¸ªç¯å¾ªç¯äº®èµ·

function red() {
  console.log('çº¢ç¯');
}
function green() {
  console.log('ç»¿ç¯');
}
function yellow() {
  console.log('é»„ç¯');
}

function light(callback, delay) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, delay);
  });
}

function step() {
  Promise.resolve()
    .then(() => light(red, 3000))
    .then(() => light(green, 2000))
    .then(() => light(yellow, 1000))
    .then(() => step()); // å¾ªç¯
}

step();
```

### 7.3 å®ç° Promise.map

```javascript
/**
 * Promise.map
 * ç±»ä¼¼ Promise.allï¼Œä½†å¯ä»¥æ§åˆ¶å¹¶å‘æ•°
 */
Promise.map = function(promises, concurrency = Infinity) {
  return new Promise((resolve, reject) => {
    const results = [];
    const total = promises.length;
    let completed = 0;
    let running = 0;
    let index = 0;

    function run() {
      if (completed === total) {
        return resolve(results);
      }

      while (running < concurrency && index < total) {
        const currentIndex = index;
        running++;
        index++;

        Promise.resolve(promises[currentIndex])
          .then(value => {
            results[currentIndex] = value;
            completed++;
            running--;
            run();
          })
          .catch(reject);
      }
    }

    run();
  });
};

// æµ‹è¯•
const tasks = [
  () => new Promise(resolve => setTimeout(() => resolve(1), 1000)),
  () => new Promise(resolve => setTimeout(() => resolve(2), 500)),
  () => new Promise(resolve => setTimeout(() => resolve(3), 800))
];

Promise.map(tasks.map(task => task()), 2).then(console.log);
```

### 7.4 å®ç° promisify

```javascript
/**
 * å°† callback é£æ ¼çš„å‡½æ•°è½¬ä¸º Promise é£æ ¼
 */
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  };
}

// ä½¿ç”¨ç¤ºä¾‹
const fs = require('fs');
const readFilePromise = promisify(fs.readFile);

readFilePromise('file.txt', 'utf8')
  .then(content => console.log(content))
  .catch(error => console.error(error));
```

### 7.5 å®ç° Promise ä¸²è¡Œæ‰§è¡Œ

```javascript
/**
 * ä¸²è¡Œæ‰§è¡Œ Promise
 */
function sequencePromises(promises) {
  return promises.reduce((prev, current) => {
    return prev.then(current);
  }, Promise.resolve());
}

// ä½¿ç”¨ç¤ºä¾‹
const tasks = [
  () => new Promise(resolve => {
    setTimeout(() => {
      console.log('ä»»åŠ¡1');
      resolve();
    }, 1000);
  }),
  () => new Promise(resolve => {
    setTimeout(() => {
      console.log('ä»»åŠ¡2');
      resolve();
    }, 500);
  }),
  () => new Promise(resolve => {
    setTimeout(() => {
      console.log('ä»»åŠ¡3');
      resolve();
    }, 800);
  })
];

sequencePromises(tasks);
// è¾“å‡º: ä»»åŠ¡1 (1ç§’å) -> ä»»åŠ¡2 (0.5ç§’å) -> ä»»åŠ¡3 (0.8ç§’å)
```

---

## å…«ã€å®æˆ˜åº”ç”¨åœºæ™¯

### 8.1 è¯·æ±‚è¶…æ—¶æ§åˆ¶

```javascript
function timeoutPromise(promise, timeout = 5000) {
  return Promise.race([
    promise,
    new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`è¯·æ±‚è¶…æ—¶ï¼Œè¶…è¿‡ ${timeout}ms`));
      }, timeout);
    })
  ]);
}

// ä½¿ç”¨ç¤ºä¾‹
const fetchData = fetch('https://api.example.com/data');

timeoutPromise(fetchData, 3000)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

### 8.2 å›¾ç‰‡é¢„åŠ è½½

```javascript
function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${url}`));
    img.src = url;
  });
}

function preloadImages(urls) {
  const promises = urls.map(url => loadImage(url));
  return Promise.all(promises);
}

// ä½¿ç”¨ç¤ºä¾‹
const imageUrls = [
  'image1.jpg',
  'image2.jpg',
  'image3.jpg'
];

preloadImages(imageUrls)
  .then(images => {
    console.log('æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ', images);
  })
  .catch(error => {
    console.error('å›¾ç‰‡åŠ è½½å¤±è´¥', error);
  });
```

### 8.3 ç¼“å­˜ Promise ç»“æœ

```javascript
function cachePromise(fn) {
  let cache = null;
  let cacheTime = 0;
  const CACHE_DURATION = 60000; // ç¼“å­˜1åˆ†é’Ÿ

  return function(...args) {
    const now = Date.now();
    
    // ç¼“å­˜æœªè¿‡æœŸï¼Œç›´æ¥è¿”å›
    if (cache && now - cacheTime < CACHE_DURATION) {
      return Promise.resolve(cache);
    }

    // æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
    return fn(...args).then(result => {
      cache = result;
      cacheTime = now;
      return result;
    });
  };
}

// ä½¿ç”¨ç¤ºä¾‹
const fetchUserData = cachePromise((userId) => {
  return fetch(`https://api.example.com/users/${userId}`)
    .then(response => response.json());
});

// ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œå‘èµ·è¯·æ±‚
fetchUserData(123).then(data => console.log(data));

// 1åˆ†é’Ÿå†…å†æ¬¡è°ƒç”¨ï¼Œç›´æ¥è¿”å›ç¼“å­˜
fetchUserData(123).then(data => console.log(data));
```

### 8.4 Promise è¯·æ±‚å»é‡

```javascript
/**
 * ç›¸åŒçš„è¯·æ±‚åœ¨ pending æœŸé—´ï¼Œåªå‘èµ·ä¸€æ¬¡
 */
function dedupeFetch() {
  const pendingPromises = new Map();

  return function(url, options) {
    const key = `${url}_${JSON.stringify(options)}`;

    // å¦‚æœå·²æœ‰ç›¸åŒè¯·æ±‚åœ¨ pendingï¼Œè¿”å›è¯¥ Promise
    if (pendingPromises.has(key)) {
      return pendingPromises.get(key);
    }

    // åˆ›å»ºæ–°è¯·æ±‚
    const promise = fetch(url, options)
      .then(response => response.json())
      .finally(() => {
        // è¯·æ±‚å®Œæˆååˆ é™¤
        pendingPromises.delete(key);
      });

    pendingPromises.set(key, promise);
    return promise;
  };
}

const fetchData = dedupeFetch();

// åŒæ—¶å‘èµ·ä¸‰ä¸ªç›¸åŒè¯·æ±‚ï¼Œå®é™…åªä¼šå‘é€ä¸€æ¬¡
fetchData('/api/data', { method: 'GET' }).then(console.log);
fetchData('/api/data', { method: 'GET' }).then(console.log);
fetchData('/api/data', { method: 'GET' }).then(console.log);
```

---

## ä¹ã€æ€»ç»“ä¸é¢è¯•è¦ç‚¹

### 9.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹

1. **Promise ä¸‰ç§çŠ¶æ€**
   - pending, fulfilled, rejected
   - çŠ¶æ€åªèƒ½å•å‘è½¬æ¢ï¼Œä¸å¯é€†

2. **Promise çš„å…³é”®æœºåˆ¶**
   - å›è°ƒé˜Ÿåˆ—ï¼ˆå¤„ç†å¼‚æ­¥ï¼‰
   - é“¾å¼è°ƒç”¨ï¼ˆthen è¿”å›æ–° Promiseï¼‰
   - å€¼ä¼ é€’ï¼ˆresolvePromiseï¼‰

3. **å¾®ä»»åŠ¡ä¸å®ä»»åŠ¡**
   - Promise.then æ˜¯å¾®ä»»åŠ¡
   - setTimeout æ˜¯å®ä»»åŠ¡
   - å¾®ä»»åŠ¡ä¼˜å…ˆäºå®ä»»åŠ¡æ‰§è¡Œ

4. **é”™è¯¯å¤„ç†**
   - catch å¯ä»¥æ•è· Promise é“¾ä¸­çš„æ‰€æœ‰é”™è¯¯
   - finally æ— è®ºæˆåŠŸå¤±è´¥éƒ½ä¼šæ‰§è¡Œ
   - æœªæ•è·çš„ Promise é”™è¯¯ä¼šå¯¼è‡´ unhandledRejection

### 9.2 é¢è¯•é«˜é¢‘é—®é¢˜

**Q1: Promise è§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ**
- è§£å†³å›è°ƒåœ°ç‹±ï¼ˆcallback hellï¼‰
- ç»Ÿä¸€å¼‚æ­¥æ“ä½œçš„æ¥å£
- æ›´å¥½çš„é”™è¯¯å¤„ç†æœºåˆ¶
- æ”¯æŒé“¾å¼è°ƒç”¨

**Q2: Promise å’Œ async/await çš„åŒºåˆ«ï¼Ÿ**
- async/await æ˜¯ Promise çš„è¯­æ³•ç³–
- async/await ä½¿å¼‚æ­¥ä»£ç çœ‹èµ·æ¥åƒåŒæ­¥ä»£ç 
- é”™è¯¯å¤„ç†: Promise ç”¨ catchï¼Œasync/await ç”¨ try/catch

**Q3: Promise.all å’Œ Promise.allSettled çš„åŒºåˆ«ï¼Ÿ**
- Promise.all: ä»»ä½•ä¸€ä¸ªå¤±è´¥å°±ç«‹å³ reject
- Promise.allSettled: ç­‰å¾…æ‰€æœ‰ Promise å®Œæˆï¼Œæ— è®ºæˆåŠŸå¤±è´¥

**Q4: å¦‚ä½•å–æ¶ˆä¸€ä¸ª Promiseï¼Ÿ**
- Promise æœ¬èº«ä¸æ”¯æŒå–æ¶ˆ
- å¯ä»¥ä½¿ç”¨ AbortControllerï¼ˆFetch APIï¼‰
- æˆ–è¿”å›ä¸€ä¸ªæ°¸è¿œ pending çš„ Promise æ¥"ä¸­æ–­"é“¾æ¡

### 9.3 æ‰‹å†™èƒ½åŠ›æ£€æŸ¥æ¸…å•

âœ… èƒ½å®ç°åŸºç¡€çš„ Promiseï¼ˆçŠ¶æ€ç®¡ç†ã€resolve/rejectï¼‰
âœ… èƒ½å®ç° then æ–¹æ³•çš„é“¾å¼è°ƒç”¨
âœ… èƒ½å®ç° resolvePromiseï¼ˆå¤„ç†å„ç§è¿”å›å€¼ï¼‰
âœ… èƒ½å®ç° Promise.all / race / allSettled / any
âœ… èƒ½å®ç° Promise.resolve / reject
âœ… ç†è§£å¾®ä»»åŠ¡ä¸å®ä»»åŠ¡çš„æ‰§è¡Œé¡ºåº
âœ… èƒ½è§£å†³å®é™…é—®é¢˜ï¼ˆå¹¶å‘æ§åˆ¶ã€é‡è¯•ã€è¶…æ—¶ç­‰ï¼‰

---

## åã€å®Œæ•´å¯æµ‹è¯•ä»£ç 

```javascript
/**
 * å®Œæ•´çš„ MyPromise å®ç°
 * ç¬¦åˆ Promises/A+ è§„èŒƒ
 */
class MyPromise {
  static PENDING = 'pending';
  static FULFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.state = MyPromise.PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (value instanceof MyPromise) {
        return value.then(resolve, reject);
      }
      if (this.state === MyPromise.PENDING) {
        this.state = MyPromise.FULFILLED;
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === MyPromise.PENDING) {
        this.state = MyPromise.REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

    const promise2 = new MyPromise((resolve, reject) => {
      const fulfilledMicrotask = () => {
        queueMicrotask(() => {
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      const rejectedMicrotask = () => {
        queueMicrotask(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      if (this.state === MyPromise.FULFILLED) {
        fulfilledMicrotask();
      } else if (this.state === MyPromise.REJECTED) {
        rejectedMicrotask();
      } else {
        this.onFulfilledCallbacks.push(fulfilledMicrotask);
        this.onRejectedCallbacks.push(rejectedMicrotask);
      }
    });

    return promise2;
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  finally(onFinally) {
    return this.then(
      value => MyPromise.resolve(onFinally()).then(() => value),
      reason => MyPromise.resolve(onFinally()).then(() => { throw reason })
    );
  }

  static resolve(value) {
    if (value instanceof MyPromise) return value;
    return new MyPromise(resolve => resolve(value));
  }

  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }

  static all(promises) {
    return new MyPromise((resolve, reject) => {
      if (!Array.isArray(promises)) {
        return reject(new TypeError('Argument must be an array'));
      }
      const results = [];
      let count = 0;
      if (promises.length === 0) return resolve(results);

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => {
            results[index] = value;
            count++;
            if (count === promises.length) resolve(results);
          },
          reject
        );
      });
    });
  }

  static race(promises) {
    return new MyPromise((resolve, reject) => {
      if (!Array.isArray(promises)) {
        return reject(new TypeError('Argument must be an array'));
      }
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(resolve, reject);
      });
    });
  }

  static allSettled(promises) {
    return new MyPromise((resolve) => {
      if (!Array.isArray(promises)) {
        return reject(new TypeError('Argument must be an array'));
      }
      const results = [];
      let count = 0;
      if (promises.length === 0) return resolve(results);

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => {
            results[index] = { status: 'fulfilled', value };
            count++;
            if (count === promises.length) resolve(results);
          },
          reason => {
            results[index] = { status: 'rejected', reason };
            count++;
            if (count === promises.length) resolve(results);
          }
        );
      });
    });
  }

  static any(promises) {
    return new MyPromise((resolve, reject) => {
      if (!Array.isArray(promises)) {
        return reject(new TypeError('Argument must be an array'));
      }
      const errors = [];
      let count = 0;
      if (promises.length === 0) {
        return reject(new AggregateError([], 'All promises were rejected'));
      }

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          resolve,
          reason => {
            errors[index] = reason;
            count++;
            if (count === promises.length) {
              reject(new AggregateError(errors, 'All promises were rejected'));
            }
          }
        );
      });
    });
  }
}

function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected for promise'));
  }

  if (x instanceof MyPromise) {
    x.then(resolve, reject);
    return;
  }

  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let called = false;
    try {
      const then = x.then;
      if (typeof then === 'function') {
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            resolvePromise(promise2, y, resolve, reject);
          },
          r => {
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        resolve(x);
      }
    } catch (error) {
      if (called) return;
      called = true;
      reject(error);
    }
  } else {
    resolve(x);
  }
}

// ==================== æµ‹è¯•ç”¨ä¾‹ ====================

console.log('=== æµ‹è¯•1: åŸºæœ¬åŠŸèƒ½ ===');
new MyPromise((resolve) => {
  setTimeout(() => resolve('æˆåŠŸ'), 100);
}).then(value => console.log('ç»“æœ:', value));

console.log('\n=== æµ‹è¯•2: é“¾å¼è°ƒç”¨ ===');
MyPromise.resolve(1)
  .then(value => value + 1)
  .then(value => value * 2)
  .then(value => console.log('é“¾å¼ç»“æœ:', value));

console.log('\n=== æµ‹è¯•3: é”™è¯¯å¤„ç† ===');
MyPromise.reject('é”™è¯¯')
  .catch(error => console.log('æ•è·åˆ°:', error));

console.log('\n=== æµ‹è¯•4: Promise.all ===');
MyPromise.all([
  MyPromise.resolve(1),
  MyPromise.resolve(2),
  MyPromise.resolve(3)
]).then(values => console.log('all ç»“æœ:', values));

console.log('\n=== æµ‹è¯•5: Promise.race ===');
MyPromise.race([
  new MyPromise(resolve => setTimeout(() => resolve('æ…¢'), 1000)),
  new MyPromise(resolve => setTimeout(() => resolve('å¿«'), 100))
]).then(value => console.log('race ç»“æœ:', value));
```

---

**ğŸ¯ å­¦ä¹ å»ºè®®ï¼š**

1. **ç†è§£åŸç†**: å…ˆç†è§£ Promise çš„çŠ¶æ€æœºåˆ¶å’Œæ‰§è¡Œæµç¨‹
2. **åŠ¨æ‰‹å®ç°**: ä»ç®€å•ç‰ˆæœ¬å¼€å§‹ï¼Œé€æ­¥å®Œå–„åŠŸèƒ½
3. **è°ƒè¯•æµ‹è¯•**: è¿è¡Œä»£ç ï¼Œè§‚å¯Ÿè¾“å‡ºï¼Œç†è§£æ¯ä¸€æ­¥
4. **åº”ç”¨å®è·µ**: åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ Promise è§£å†³é—®é¢˜
5. **é¢è¯•å‡†å¤‡**: èƒ½å¤Ÿæ¸…æ™°è§£é‡ŠåŸç†ï¼Œæµç•…æ‰‹å†™ä»£ç 

**ğŸ’¡ è®°ä½è¿™å¥è¯ï¼š**
> Promise çš„æ ¸å¿ƒæ˜¯çŠ¶æ€ç®¡ç† + å›è°ƒé˜Ÿåˆ— + é“¾å¼è°ƒç”¨ï¼ŒæŒæ¡è¿™ä¸‰ç‚¹å°±æŒæ¡äº† Promise çš„ç²¾é«“ï¼

ç¥ä½ é¢è¯•é¡ºåˆ©ï¼Œå·¥ä½œæ¸¸åˆƒæœ‰ä½™ï¼ğŸš€