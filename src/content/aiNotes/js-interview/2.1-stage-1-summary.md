---
title: 2.1 - 第一阶段面试题总结
aiNotebook: js-interview
date: 2026-02-01
tags: ['JavaScript', '闭包', '面试']
excerpt: 第一阶段面试题总结
order: 7
---

# JavaScript 核心技术点面试题汇总

## 目录
- [数据类型、类型判断、类型转换](#数据类型类型判断类型转换)
- [作用域、闭包、this指向](#作用域闭包this指向)
- [原型链、继承](#原型链继承)
- [Event Loop、宏任务与微任务](#event-loop宏任务与微任务)
- [Promise、async/await、Generator](#promiseasyncawaitgenerator)

---

## 数据类型、类型判断、类型转换

### 考查重点分析
面试官主要考查：
1. **基础扎实度**：对8种数据类型的理解深度
2. **类型判断**：各种判断方法的优缺点和适用场景
3. **隐式转换**：类型转换规则的掌握，特别是边界case
4. **实际应用**：在实际开发中如何避免类型相关的bug

### 面试题

#### 基础题
1. JavaScript有哪些数据类型？基本类型和引用类型有什么区别？

2. `typeof` 和 `instanceof` 的区别是什么？它们各有什么局限性？

3. 如何准确判断一个变量是数组类型？请列举至少3种方法。

4. 说说 `null` 和 `undefined` 的区别，以及 `typeof null` 为什么返回 `"object"`？

#### 进阶题
5. 实现一个通用的类型判断函数 `getType()`，能准确判断所有JavaScript数据类型。

6. 以下代码的输出结果是什么？为什么？
```javascript
console.log([] + []);
console.log([] + {});
console.log({} + []);
console.log({} + {});
console.log(true + false);
console.log(1 + "2" + 3);
console.log(1 + +"2" + 3);
console.log(1 + -"1" + 2);
console.log(+"1" + "1" + "2");
console.log("A" - "B" + 2);
```

7. 什么是装箱和拆箱？请举例说明。

8. 解释以下代码的执行结果：
```javascript
console.log(0.1 + 0.2 === 0.3);
console.log(0.1 + 0.2);
// 如何解决浮点数精度问题？
```

#### 高频核心题
9. 请实现一个深拷贝函数 `deepClone()`，要求：
   - 支持对象、数组、Date、RegExp、Map、Set等类型
   - 解决循环引用问题
   - 考虑Symbol作为key的情况

10. 以下比较运算的结果是什么？请解释原因：
```javascript
console.log([] == ![]);
console.log([] == false);
console.log({} == false);
console.log(null == undefined);
console.log(null === undefined);
console.log(NaN == NaN);
console.log(Object.is(NaN, NaN));
console.log(Object.is(+0, -0));
```

11. 如何判断两个对象是否相等？请实现一个 `isEqual()` 函数。

12. 说说 `==` 和 `===` 的区别，以及完整的类型转换规则。

---

## 作用域、闭包、this指向

### 考查重点分析
面试官主要考查：
1. **作用域理解**：词法作用域、作用域链的概念
2. **闭包原理**：闭包的形成条件、使用场景和内存管理
3. **this绑定**：各种this指向的判断和改变this的方法
4. **实战能力**：在复杂场景下准确判断作用域和this

### 面试题

#### 基础题
13. 什么是作用域？JavaScript中有哪几种作用域？

14. 什么是作用域链？解释变量查找的过程。

15. `var`、`let`、`const` 的区别是什么？什么是暂时性死区？

16. 什么是闭包？闭包有什么作用和应用场景？

#### 进阶题
17. 分析以下代码的输出结果：
```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 如何修改代码让其输出 0, 1, 2, 3, 4？请给出至少3种方案。
```

18. 请解释以下代码的执行结果：
```javascript
var name = 'global';
var obj = {
  name: 'obj',
  getName: function() {
    return this.name;
  }
};

console.log(obj.getName());
var fn = obj.getName;
console.log(fn());
console.log((obj.getName)());
console.log((obj.getName = obj.getName)());
```

19. 闭包会造成内存泄漏吗？如何避免？

20. 说说 `call`、`apply`、`bind` 的区别和使用场景。

#### 高频核心题
21. 手写实现 `call`、`apply`、`bind` 方法。

22. 箭头函数和普通函数的区别是什么？箭头函数的this指向规则是什么？

23. 分析以下代码的输出：
```javascript
var length = 10;
function fn() {
  console.log(this.length);
}

var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  }
};

obj.method(fn, 1, 2, 3);
```

24. 实现一个函数柯里化 `curry()` 函数，要求支持以下用法：
```javascript
function add(a, b, c) {
  return a + b + c;
}
const curriedAdd = curry(add);
curriedAdd(1)(2)(3); // 6
curriedAdd(1, 2)(3); // 6
curriedAdd(1)(2, 3); // 6
```

25. 什么是立即执行函数（IIFE）？它有什么作用？

26. 分析以下代码的作用域和输出：
```javascript
var a = 1;
function foo() {
  console.log(a);
  var a = 2;
  console.log(a);
  function a() {}
  console.log(a);
}
foo();
```

---

## 原型链、继承

### 考查重点分析
面试官主要考查：
1. **原型理解**：prototype、__proto__、constructor的关系
2. **原型链机制**：属性查找、方法继承的过程
3. **继承方式**：各种继承方式的实现和优缺点
4. **ES6 Class**：Class语法糖与传统继承的关系

### 面试题

#### 基础题
27. 什么是原型？什么是原型链？

28. `prototype` 和 `__proto__` 的区别是什么？

29. `constructor` 属性的作用是什么？

30. 如何判断一个属性是对象自身的还是原型上的？

#### 进阶题
31. 解释以下代码的输出结果：
```javascript
function Person() {}
Person.prototype.name = 'person';

var p1 = new Person();
var p2 = new Person();

p1.name = 'p1';
console.log(p1.name);
console.log(p2.name);

delete p1.name;
console.log(p1.name);
```

32. 请画出以下代码的原型链关系图：
```javascript
function Parent() {}
function Child() {}
Child.prototype = new Parent();
var child = new Child();
```

33. `instanceof` 的实现原理是什么？请手写实现一个 `myInstanceof()`。

34. `new` 操作符具体做了什么？请手写实现一个 `myNew()`。

#### 高频核心题
35. JavaScript有哪些继承方式？请分别实现并说明各自的优缺点：
    - 原型链继承
    - 构造函数继承
    - 组合继承
    - 原型式继承
    - 寄生式继承
    - 寄生组合式继承

36. ES6 的 Class 继承与 ES5 的继承有什么区别？

37. 如何创建一个没有原型的对象？

38. 实现一个寄生组合式继承，这是最优的继承方式。

39. 分析以下代码的输出：
```javascript
function Foo() {
  getName = function() { console.log(1); };
  return this;
}
Foo.getName = function() { console.log(2); };
Foo.prototype.getName = function() { console.log(3); };
var getName = function() { console.log(4); };
function getName() { console.log(5); }

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

40. 什么是原型污染？如何防止原型污染？

---

## Event Loop、宏任务与微任务

### 考查重点分析
面试官主要考查：
1. **执行机制**：JavaScript单线程、事件循环的理解
2. **任务分类**：宏任务和微任务的区别和执行顺序
3. **实际应用**：能够准确分析异步代码的执行顺序
4. **浏览器与Node**：不同环境下Event Loop的差异

### 面试题

#### 基础题
41. 什么是Event Loop（事件循环）？

42. 什么是宏任务（macro task）和微任务（micro task）？请分别列举。

43. JavaScript为什么是单线程的？

44. 解释同步任务和异步任务的执行顺序。

#### 进阶题
45. 说说宏任务和微任务的执行顺序，以及一个完整的Event Loop流程。

46. 分析以下代码的输出顺序：
```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

47. 分析以下代码的输出顺序：
```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

new Promise((resolve) => {
  console.log('4');
  resolve();
}).then(() => {
  console.log('5');
}).then(() => {
  console.log('6');
});

setTimeout(() => {
  console.log('7');
  Promise.resolve().then(() => {
    console.log('8');
  });
}, 0);

console.log('9');
```

48. `process.nextTick()` 和 `setImmediate()` 的区别是什么？（Node环境）

#### 高频核心题
49. 分析以下复杂代码的输出顺序：
```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

50. 浏览器的Event Loop和Node.js的Event Loop有什么区别？

51. 分析以下代码的执行顺序并解释原因：
```javascript
Promise.resolve().then(() => {
  console.log('Promise1');
  setTimeout(() => {
    console.log('setTimeout2');
  }, 0);
});

setTimeout(() => {
  console.log('setTimeout1');
  Promise.resolve().then(() => {
    console.log('Promise2');
  });
}, 0);
```

52. `requestAnimationFrame` 在Event Loop中的位置是什么？

---

## Promise、async/await、Generator

### 考查重点分析
面试官主要考查：
1. **Promise原理**：状态管理、链式调用、错误处理
2. **手写能力**：能否手写符合Promise/A+规范的实现
3. **async/await**：语法糖的本质和错误处理
4. **Generator**：迭代器协议和异步流程控制
5. **实战经验**：异步编程的最佳实践

### 面试题

#### 基础题
53. 什么是Promise？Promise有哪几种状态？

54. Promise如何解决回调地狱问题？

55. Promise的 `.then()` 方法可以接收几个参数？分别是什么？

56. `.then()` 和 `.catch()` 的区别是什么？

57. 什么是Promise链？如何实现Promise的链式调用？

#### 进阶题
58. 分析以下代码的输出：
```javascript
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();
  console.log(2);
});

promise.then(() => {
  console.log(3);
});

console.log(4);
```

59. Promise.all()、Promise.race()、Promise.allSettled()、Promise.any() 的区别和使用场景？

60. 手写实现 `Promise.all()`。

61. 手写实现 `Promise.race()`。

62. 如何取消一个Promise？

63. 分析以下代码的执行结果：
```javascript
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });

Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3;
  })
  .then(res => {
    console.log(res);
  });
```

#### 高频核心题
64. 手写实现一个符合Promise/A+规范的Promise，要求：
    - 实现基本的状态管理（pending、fulfilled、rejected）
    - 实现 then 方法的链式调用
    - 处理异步操作
    - 实现值的穿透
    - 处理循环引用

65. 分析以下代码的输出：
```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

async1();

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
}).then(function() {
  console.log('promise3');
});
```

66. async/await 的原理是什么？它是如何实现的？

67. async/await 如何进行错误处理？请给出多种方案。

68. 分析以下代码的执行结果：
```javascript
async function test() {
  try {
    await Promise.reject('error');
  } catch(e) {
    console.log(e);
  }
  return Promise.resolve('success');
}

test().then(res => {
  console.log(res);
});
```

69. Generator函数是什么？它有什么特点和应用场景？

70. Generator函数与async/await的关系是什么？如何用Generator实现async/await？

71. 实现一个自动执行Generator函数的函数 `run()`（co库的简化版）。

72. 实现一个Promise的串行执行和并行限制：
    - 串行执行：依次执行多个异步任务
    - 并行限制：最多同时执行N个Promise

73. 实现一个带有重试功能的Promise请求函数 `retryRequest()`。

74. 实现一个Promise的超时控制函数 `timeoutPromise()`。

75. 如何处理多个并发请求，并保证它们按照发起顺序返回结果？

---

## 综合应用题

### 考查重点分析
面试官主要考查：
1. **综合能力**：多个知识点的综合运用
2. **问题分析**：对复杂问题的分析和解决能力
3. **代码质量**：代码的健壮性、可维护性
4. **工程思维**：在实际项目中的应用经验

### 面试题

76. 实现一个EventEmitter类（发布订阅模式），要求：
    - 支持on（订阅）、emit（发布）、off（取消订阅）
    - 支持once（只触发一次）
    - 考虑内存泄漏问题

77. 实现一个LazyMan，支持链式调用：
```javascript
LazyMan('Hank').sleep(3).eat('dinner');
// 输出：
// Hi! This is Hank!
// (等待3秒)
// Wake up after 3
// Eat dinner~
```

78. 实现一个任务调度器Scheduler：
```javascript
class Scheduler {
  constructor(maxCount) {
    // 最多同时运行maxCount个任务
  }
  add(promiseCreator) {
    // 添加任务
  }
}

const scheduler = new Scheduler(2);
const addTask = (time, order) => {
  scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');
// 输出：2 3 1 4
```

79. 实现一个带缓存的异步请求函数，相同的请求在pending期间不会重复发送。

80. 分析并优化以下代码的性能问题：
```javascript
async function processData(dataList) {
  const results = [];
  for (let data of dataList) {
    const result = await fetchData(data);
    results.push(result);
  }
  return results;
}
```

---

## 学习建议

1. **系统学习**：不要孤立地学习每个知识点，理解它们之间的联系
2. **动手实践**：所有手写题都要自己实现一遍，不要只看答案
3. **理解原理**：知其然更要知其所以然，深入理解底层原理
4. **代码调试**：多用debugger和console.log，观察代码执行流程
5. **总结归纳**：建立自己的知识体系，定期复习和总结
6. **实战应用**：在实际项目中应用这些知识，加深理解

---

## 答题思路

### 1. 基础概念题
- 先给出准确定义
- 举例说明
- 说明应用场景
- 补充注意事项

### 2. 代码输出题
- 逐行分析代码执行过程
- 画出执行流程图或调用栈
- 说明关键知识点
- 给出准确答案

### 3. 手写实现题
- 先分析需求和边界条件
- 写出清晰的代码结构
- 处理异常情况
- 优化代码性能
- 补充测试用例

### 4. 对比分析题
- 列出相同点
- 列出不同点
- 说明适用场景
- 给出选择建议

---

## 面试准备检查清单

- [ ] 理解所有基础概念
- [ ] 能够准确分析代码输出题
- [ ] 熟练手写核心API实现
- [ ] 掌握常见应用场景和解决方案
- [ ] 准备1-2个深入研究的技术点
- [ ] 整理自己的项目中相关的实战经验
- [ ] 模拟面试练习，提高表达能力

---

## 附录：推荐资源

### 书籍
- 《JavaScript高级程序设计》
- 《你不知道的JavaScript》
- 《JavaScript语言精粹》
- 《深入理解ES6》

### 在线资源
- MDN Web Docs
- JavaScript.info
- ES6标准文档
- Promise/A+规范

### 实践平台
- LeetCode
- 牛客网
- 前端面试题库

---

**最后提醒**：面试不仅仅是考查技术能力，更重要的是展现你的学习能力、思考方式和解决问题的思路。保持自信，充分准备，祝你面试成功！🚀